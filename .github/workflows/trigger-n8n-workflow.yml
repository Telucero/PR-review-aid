name: Trigger n8n Webhook with Complete PR Info

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write

jobs:
  gather-and-send:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate Run UUID
        id: uuid
        run: echo "run_token=$(uuidgen)" >> $GITHUB_OUTPUT

      - name: Fetch PR metadata
        id: pr
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch PR files (diffs/patches)
        id: files
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch PR commits
        id: commits
        uses: octokit/request-action@v2.x
        with:
          route: GET /repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/commits
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch PR diff (patch)
        id: diff
        run: |
          curl -L \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3.diff" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}" \
            > pr.diff
          DIFF_B64=$(base64 -w 0 pr.diff)
          echo "diff_b64=$DIFF_B64" >> $GITHUB_OUTPUT

      - name: Combine and send to n8n webhook and capture response
        id: n8n
        env:
          PR_DATA: ${{ steps.pr.outputs.data }}
          FILES_DATA: ${{ steps.files.outputs.data }}
          COMMITS_DATA: ${{ steps.commits.outputs.data }}
          DIFF_B64: ${{ steps.diff.outputs.diff_b64 }}
          RUN_TOKEN: ${{ steps.uuid.outputs.run_token }}
          N8N_WEBHOOK_URL: ${{ secrets.N8N_WEBHOOK_URL }}
        run: |
          set -e

          # Build payload.json using jq to avoid invalid JSON formatting
          jq -n \
            --argjson pr "$PR_DATA" \
            --argjson files "$FILES_DATA" \
            --argjson commits "$COMMITS_DATA" \
            --arg diff_base64 "$DIFF_B64" \
            --arg token "$RUN_TOKEN" \
            '{
              pr: $pr,
              files: $files,
              commits: $commits,
              diff_base64: $diff_base64,
              token: $token
            }' > payload.json

          # Post to n8n and capture response
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Content-Type: application/json" \
            --data @payload.json \
            "$N8N_WEBHOOK_URL")

          HTTP_BODY=$(echo "$RESPONSE" | sed '$d')
          HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)

          echo "n8n responded with status: $HTTP_STATUS"
          echo "n8n response body: $HTTP_BODY"

          echo "$HTTP_BODY" > response_body.json

          STATUS=$(echo "$HTTP_BODY" | jq -r ".status" | tr -d '"')
          MATCHED=$(echo "$HTTP_BODY" | jq -r ".token" | tr -d '"')

          if [ "$MATCHED" != "$RUN_TOKEN" ] || [ "$STATUS" != "completed" ]; then
            echo "n8n workflow did not complete correctly or token mismatch"
            exit 1
          fi

          if [ "$HTTP_STATUS" -lt 200 ] || [ "$HTTP_STATUS" -ge 300 ]; then
            echo "n8n workflow failed or did not complete successfully"
            exit 1
          fi
        
      - name: Parse verification claims into structured schema
        run: |
          set -e

          # Extract the embedded comment string and the PR number from response_body.json
          EMBEDDED=$(jq -r '.[0].comment' response_body.json)
          PR_NUMBER=$(jq -r '.[0].pr_number' response_body.json)

          # Extract the "formattedReview" intro text from the parsed JSON
          INTRO=$(echo "$EMBEDDED" | jq -r 'fromjson | .[0].formattedReview')

          # Extract the array of outputs (claims) for further processing
          OUTPUTS=$(echo "$EMBEDDED" | jq -r 'fromjson | .[0].output')

          # Build the detailed markdown claims from output array, grouped by file
          DETAILS=$(echo "$OUTPUTS" | jq -r '
            group_by(.file_path)
            | map({
                file_path: .[0].file_path,
                claims: map({
                  prompt: (.claim | capture("Original Prompt: (?<p>.*?)\\n").p // ""),
                  output: (.claim | capture("Original Output: (?<o>.*?)\\n").o // ""),
                  claim: (.claim | capture("Original Claim: (?<c>.*)$").c // ""),
                  context: .context,
                  line_number: (.line_number | tonumber),
                  requires_verification: (.requires_verification // false),
                  justification: (.justification // ""),
                  confidence_score: (
                    if (.confidence_score == "" or .confidence_score == null)
                    then 0.0
                    else (.confidence_score | tonumber)
                    end
                  )
                })
              })
            | map(
                "### Verification Details for \(.file_path)\n\n" +
                (.claims | map(
                  "Line \(.line_number)\n\n" +
                  "**Claim:** \(.claim)\n\n" +
                  "**Original Prompt:** \(.prompt)\n\n" +
                  "**Original Output:** \(.output)\n\n" +
                  "**Context:**\n\(.context)\n\n" +
                  "**Requires Verification:** \(.requires_verification | tostring)\n" +
                  "**Confidence Score:** \(.confidence_score)\n" +
                  "**Justification:** \(
                    if (.justification == "" or .justification == null) then
                      "_(none provided)_"
                    else
                      .justification
                    end
                  )\n"
                ) | join("\n\n---\n\n"))
              )
            | join("\n\n===\n\n")
          ')

          # Combine the extracted intro with the detailed claims
          MARKDOWN="$INTRO

          ---

          $DETAILS"

          echo "Posting PR comment to PR #$PR_NUMBER..."

          # Post the markdown comment using GitHub CLI and extracted PR number
          gh pr comment "$PR_NUMBER" --body "$MARKDOWN"
