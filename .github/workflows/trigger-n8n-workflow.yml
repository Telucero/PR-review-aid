name: Nathan

on:
  pull_request:
    types: [synchronize]
  workflow_dispatch:
    inputs:
      pr_number:
        description: Pull request number to process (maintainer-triggered runs)
        required: false
        type: string
      pr_selector:
        description: PR URL or branch name (used when pr_number is not provided)
        required: false
        type: string

permissions:
  contents: read
  pull-requests: read
  checks: write


jobs:
  gather-and-send:
    # Manual dispatch is allowed, but we verify the actor has write access before continuing.
    # Pull request runs still skip forks to avoid leaking secrets.
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event.pull_request != null && github.event.pull_request.head.repo.fork == false) }}
    runs-on: ubuntu-latest
    environment: n8n-sending
    permissions:
      contents: read
      pull-requests: read
      checks: write
    outputs:
      triggered: ${{ steps.trigger_phrase.outputs.triggered || 'false' }}
      commit_sha: ${{ steps.trigger_phrase.outputs.commit_sha || '' }}
      filtered_file_count: ${{ steps.filter_files.outputs.file_count || '0' }}
      filtered_addition_count: ${{ steps.filter_files.outputs.addition_count || '0' }}
      should_send: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && (steps.filter_files.outputs.addition_count || '0') != '0' && steps.diff_threshold.outputs.skip_send != 'true' && steps.send_payload.outputs.cancelled != 'true' && steps.send_payload.outputs.error != 'true' }}
      diff_char_count: ${{ steps.diff_threshold.outputs.diff_char_count || '0' }}
      pr_number: ${{ steps.run_context.outputs.pr_number }}
      repository: ${{ steps.run_context.outputs.repository }}
      run_url: ${{ steps.run_context.outputs.run_url }}
      response_payload: ${{ steps.send_payload.outputs.response_payload }}
      cancelled: ${{ steps.send_payload.outputs.cancelled }}
      send_executed: ${{ steps.send_payload.outputs.executed }}
      send_error: ${{ steps.send_payload.outputs.error }}
    env:
      PR_NUMBER: ${{ github.event.pull_request.number || github.event.inputs.pr_number }}
      PR_SELECTOR: ${{ github.event.inputs.pr_selector }}
      IS_MANUAL_RUN: ${{ github.event_name == 'workflow_dispatch' }}
      MIN_DIFF_CHAR_THRESHOLD: ${{ vars.N8N_MIN_DIFF_CHAR_THRESHOLD || '1000' }}
    steps:
      # Step 2: Generate unique run token
      - name: Generate Run UUID
        id: uuid
        run: echo run_token=$(uuidgen) >> $GITHUB_OUTPUT

      # Step 2b: Require dispatcher to have access
      - name: Validate dispatcher permissions
        if: ${{ github.event_name == 'workflow_dispatch' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          ACTOR: ${{ github.actor }}
        run: |
          set -euo pipefail
          PERMISSION=$(gh api \
            -H "Accept: application/vnd.github+json" \
            repos/${REPO}/collaborators/${ACTOR}/permission \
            --jq '.permission // ""')

          case $PERMISSION in
            admin|maintain|write)
              echo "✅ ${ACTOR} has ${PERMISSION} permission."
              ;;
            *)
              echo "❌ ${ACTOR} lacks write or maintain access (permission='${PERMISSION}')."
              exit 1
              ;;
          esac

      - name: Resolve PR number (manual dispatch)
        if: ${{ github.event_name == 'workflow_dispatch' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        shell: bash
        run: |
          set -euo pipefail

          if [[ -n "${PR_NUMBER:-}" ]]; then
            echo "PR_NUMBER already set to ${PR_NUMBER}"
            exit 0
          fi

          if [[ -z "${PR_SELECTOR:-}" ]]; then
            echo "No PR provided. Supply workflow_dispatch input pr_number or pr_selector (PR URL or branch name)." >&2
            exit 1
          fi

          RESOLVED_PR_NUMBER="$(gh pr view "${PR_SELECTOR}" --repo "${REPO}" --json number --jq '.number')"
          if [[ -z "${RESOLVED_PR_NUMBER:-}" ]]; then
            echo "Unable to resolve PR number from pr_selector='${PR_SELECTOR}'." >&2
            exit 1
          fi

          echo "PR_NUMBER=${RESOLVED_PR_NUMBER}" >> "$GITHUB_ENV"
          echo "Resolved PR_NUMBER=${RESOLVED_PR_NUMBER} from pr_selector='${PR_SELECTOR}'."

      - name: Check trigger phrase (+Nathan)
        id: trigger_phrase
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        shell: bash
        run: |
          set -euo pipefail

          commits_json=""
          for attempt in 1 2 3; do
            if commits_json="$(gh api --paginate "repos/${REPO}/pulls/${PR_NUMBER}/commits" 2>/dev/null | jq -s 'add' 2>/dev/null)"; then
              break
            fi
            sleep 2
          done

          if [[ -z "${commits_json:-}" ]]; then
            echo "⚠️ Unable to fetch PR commits to evaluate trigger phrase; skipping run gracefully."
            echo "triggered=false" >> "$GITHUB_OUTPUT"
            echo "commit_sha=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          sha="$(printf '%s' "$commits_json" | jq -r '.[-1].sha // ""')"
          msg="$(printf '%s' "$commits_json" | jq -r '.[-1].commit.message // ""')"

          triggered="$(printf '%s' "$commits_json" | jq -r --arg needle "+nathan" 'any(.[].commit.message?; (ascii_downcase | contains($needle)))')"
          if [[ "$triggered" == "true" ]]; then
            echo "triggered=true" >> "$GITHUB_OUTPUT"
          else
            echo "triggered=false" >> "$GITHUB_OUTPUT"
          fi

          echo "commit_sha=$sha" >> "$GITHUB_OUTPUT"
          echo "COMMIT_SHA=$sha" >> "$GITHUB_ENV"

          first_line="$(printf '%s\n' "$msg" | head -n1 | tr -d '\r')"
          echo "Latest PR commit: ${sha:-unknown} — ${first_line:-<no message>}"

      - name: Not triggered (missing +Nathan)
        if: ${{ steps.trigger_phrase.outputs.triggered != 'true' }}
        run: |
          echo "Skipping: latest PR commit message does not contain '+Nathan' or '+nathan'."

      - name: One-shot gate (check-run)
        id: oneshot
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          COMMIT_SHA: ${{ env.COMMIT_SHA }}
        shell: bash
        run: |
          set -euo pipefail

          CHECK_NAME="n8n-trigger"
          echo "proceed=true" >> "$GITHUB_OUTPUT"
          echo "skip_reason=" >> "$GITHUB_OUTPUT"
          echo "check_run_id=" >> "$GITHUB_OUTPUT"

          if [[ -z "${COMMIT_SHA:-}" ]]; then
            echo "⚠️ Missing COMMIT_SHA; skipping run gracefully."
            echo "proceed=false" >> "$GITHUB_OUTPUT"
            echo "skip_reason=missing_commit_sha" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          existing=""
          for attempt in 1 2 3; do
            if existing="$(gh api -H "Accept: application/vnd.github+json" "repos/${REPO}/commits/${COMMIT_SHA}/check-runs" 2>/dev/null)"; then
              break
            fi
            sleep 2
          done

          if [[ -n "${existing:-}" ]]; then
            status="$(printf '%s' "$existing" | jq -r --arg n "$CHECK_NAME" '.check_runs[]? | select(.name==$n) | .status' | tail -n1)"
            conclusion="$(printf '%s' "$existing" | jq -r --arg n "$CHECK_NAME" '.check_runs[]? | select(.name==$n) | .conclusion // ""' | tail -n1)"

            if [[ -n "${status:-}" ]]; then
              if [[ "$status" == "in_progress" || "$status" == "queued" ]]; then
                echo "Already running for ${COMMIT_SHA} (check-run '${CHECK_NAME}' is ${status})."
                echo "proceed=false" >> "$GITHUB_OUTPUT"
                echo "skip_reason=already_running" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              if [[ "$status" == "completed" && "${conclusion:-}" != "failure" ]]; then
                echo "Already processed for ${COMMIT_SHA} (check-run '${CHECK_NAME}' conclusion='${conclusion:-unknown}')."
                echo "proceed=false" >> "$GITHUB_OUTPUT"
                echo "skip_reason=already_processed" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              if [[ "$status" == "completed" && "${conclusion:-}" == "failure" ]]; then
                echo "Previous run failed for ${COMMIT_SHA}; allowing retry."
              fi
            fi
          else
            echo "⚠️ Unable to query existing check-runs; proceeding without one-shot enforcement."
            exit 0
          fi

          started_at="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          check_id=""
          for attempt in 1 2 3; do
            if check_id="$(
              gh api -X POST -H "Accept: application/vnd.github+json" "repos/${REPO}/check-runs" \
                -f name="${CHECK_NAME}" \
                -f head_sha="${COMMIT_SHA}" \
                -f status="in_progress" \
                -f started_at="${started_at}" \
                --jq '.id' 2>/dev/null
            )"; then
              break
            fi
            sleep 2
          done

          if [[ -z "${check_id:-}" ]]; then
            echo "⚠️ Unable to create check-run; proceeding without one-shot enforcement."
            exit 0
          fi

          echo "check_run_id=${check_id}" >> "$GITHUB_OUTPUT"

      - name: Capture run context
        id: run_context
        run: |
          echo pr_number=${PR_NUMBER} >> $GITHUB_OUTPUT
          echo repository=${GITHUB_REPOSITORY} >> $GITHUB_OUTPUT
          echo run_url=${GITHUB_SERVER_URL:-https://github.com}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID} >> $GITHUB_OUTPUT

      # Step 3: Pre-flight validation
      - name: Validate setup
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' }}
        run: |
          if [[ -z ${{ secrets.GITHUB_TOKEN }} ]]; then
            echo Missing GITHUB_TOKEN secret.
            exit 1
          fi

          if [[ -z ${PR_NUMBER} ]]; then
            echo No PR number provided. For manual runs, supply pr_number input.
            exit 1
          fi

          if [[ -z ${{ secrets.N8N_SENDING_TOKEN }} ]]; then
            echo Missing N8N_SENDING_TOKEN secret.
            exit 1
          fi

          if [[ ${IS_MANUAL_RUN} == true ]]; then
            echo ℹ️ Maintainer-triggered run for PR #${PR_NUMBER}
          fi

      # Step 4: Fetch PR metadata, files, commits
      - name: Fetch PR metadata
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' }}
        run: |
          gh api repos/${{ github.repository }}/pulls/${PR_NUMBER} > pr.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Guard PR head SHA and set base SHA
        id: sha_guard
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          base_sha="$(jq -r '.base.sha // ""' pr.json)"
          head_sha="$(jq -r '.head.sha // ""' pr.json)"
          expected="${COMMIT_SHA:-}"

          if [[ -z "${base_sha:-}" || -z "${head_sha:-}" || -z "${expected:-}" ]]; then
            echo "sha_ok=false" >> "$GITHUB_OUTPUT"
            echo "Missing base/head/expected SHA; skipping gracefully."
            exit 0
          fi

          if [[ "$head_sha" != "$expected" ]]; then
            echo "sha_ok=false" >> "$GITHUB_OUTPUT"
            echo "Head SHA changed (pr.head.sha=$head_sha expected=$expected); skipping gracefully."
            exit 0
          fi

          echo "sha_ok=true" >> "$GITHUB_OUTPUT"
          echo "base_sha=$base_sha" >> "$GITHUB_OUTPUT"
          echo "head_sha=$head_sha" >> "$GITHUB_OUTPUT"
          echo "BASE_SHA=$base_sha" >> "$GITHUB_ENV"

      # Step 1 (moved): Checkout repository at the triggering commit SHA
      - name: Checkout repository
        id: checkout
        continue-on-error: true
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' }}
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          ref: ${{ env.COMMIT_SHA }}

      - name: Checkout failed
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome != 'success' }}
        run: |
          echo "Skipping: unable to checkout ref ${COMMIT_SHA:-<missing>}."

      - name: Fetch PR files and commits (stable compare)
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          BASE_SHA: ${{ env.BASE_SHA }}
          COMMIT_SHA: ${{ env.COMMIT_SHA }}
        shell: bash
        run: |
          set -euo pipefail

          compare_json=""
          for attempt in 1 2 3; do
            if compare_json="$(gh api -H "Accept: application/vnd.github+json" "repos/${REPO}/compare/${BASE_SHA}...${COMMIT_SHA}" 2>/dev/null)"; then
              break
            fi
            sleep 2
          done

          if [[ -z "${compare_json:-}" ]]; then
            echo "Unable to fetch compare JSON; skipping gracefully."
            exit 0
          fi

          printf '%s' "$compare_json" | jq '.files // []' > files.json
          printf '%s' "$compare_json" | jq '.commits // []' > commits.json

      # Step 5: Download stable diff for BASE_SHA...COMMIT_SHA
      - name: Fetch PR diff
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          BASE_SHA: ${{ env.BASE_SHA }}
          COMMIT_SHA: ${{ env.COMMIT_SHA }}
        shell: bash
        run: |
          set -euo pipefail

          ok=false
          for attempt in 1 2 3; do
            if gh api -H "Accept: application/vnd.github.v3.diff" "repos/${REPO}/compare/${BASE_SHA}...${COMMIT_SHA}" > pr.diff 2>/dev/null; then
              ok=true
              break
            fi
            sleep 2
          done

          if [[ "$ok" != "true" ]]; then
            echo "Unable to fetch compare diff; skipping gracefully."
            exit 0
          fi

      - name: Filter excluded files
        id: filter_files
        shell: bash
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' }}
        run: |
          set -euo pipefail

          python3 - <<'PY'
          from pathlib import Path
          import json, re, sys

          files_path = Path("files.json")
          try:
              raw = files_path.read_text(encoding="utf-8")
          except FileNotFoundError:
              print("files.json not found", file=sys.stderr)
              sys.exit(1)

          try:
              data = json.loads(raw)
          except json.JSONDecodeError as exc:
              print(f"Unable to decode files.json as JSON: {exc}", file=sys.stderr)
              print(raw)
              data = []

          if not isinstance(data, list):
              print("files.json payload is not an array; logging contents and treating as empty list.")
              print(raw)
              data = []

          # Exclude paths under ".ai" directory (any depth) or any filename containing "llms"
          pattern_ai_dir = re.compile(r'(^|/)\.ai(/|$)', re.IGNORECASE)
          pattern_llms   = re.compile(r'llms', re.IGNORECASE)

          filtered = []
          total_additions = 0
          for item in data:
              if not isinstance(item, dict):
                  continue
              filename = item.get("filename") or ""
              status = (item.get("status") or "").lower()
              if status == "removed":
                  continue
              if pattern_ai_dir.search(filename) or pattern_llms.search(filename):
                  continue
              filtered.append(item)
              additions = item.get("additions")
              if isinstance(additions, int):
                  total_additions += additions

          files_path.write_text(json.dumps(filtered), encoding="utf-8")
          Path("file_count.txt").write_text(str(len(filtered)), encoding="utf-8")
          Path("addition_count.txt").write_text(str(total_additions), encoding="utf-8")
          PY
              FILE_COUNT=$(<file_count.txt)
              ADDITION_COUNT=$(<addition_count.txt)
              {
                echo "file_count=${FILE_COUNT}"
                echo "addition_count=${ADDITION_COUNT}"
              } >> "$GITHUB_OUTPUT"
              echo "Remaining files after filter: ${FILE_COUNT}"
              echo "Total additions after filter: ${ADDITION_COUNT}"

      # Step 7: Strip excluded paths from diff payload
      - name: Filter diff to excluded paths
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' }}
        run: |
          python3 - <<'PY'
          import pathlib, textwrap; exec(textwrap.dedent('''\
          from pathlib import Path

          diff_path = Path('pr.diff')
          if not diff_path.exists():
            raise SystemExit('pr.diff missing')

          def is_excluded(path: str) -> bool:
            lower = path.lower()
            return ('/.ai/' in lower or lower.startswith('.ai/') or lower.endswith('/.ai') or 'llms' in lower)

          out_lines = []
          current_chunk = []
          exclude_chunk = False

          with diff_path.open('r', encoding='utf-8', errors='replace') as diff_file:
              for line in diff_file:
                  if line.startswith('diff --git '):
                      if current_chunk and not exclude_chunk:
                          out_lines.extend(current_chunk)
                      current_chunk = [line]
                      exclude_chunk = False
                      parts = line.strip().split()
                      if len(parts) >= 4:
                          a_path = parts[2][2:]
                          b_path = parts[3][2:]
                          if is_excluded(a_path) or is_excluded(b_path):
                              exclude_chunk = True
                  else:
                      current_chunk.append(line)

          if current_chunk and not exclude_chunk:
              out_lines.extend(current_chunk)

          diff_path.write_text(''.join(out_lines), encoding='utf-8')
          '''))
          PY

      # Step 8: Compress & encode diff for payload
      - name: Compress filtered diff
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' }}
        run: |
          gzip -c pr.diff > pr.diff.gz
          base64 -w 0 pr.diff.gz > diff.b64

      - name: Build added_lines from diff
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' && steps.filter_files.outputs.addition_count != '0' }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import re
          from pathlib import Path

          diff_path = Path("pr.diff")
          if not diff_path.exists():
              raise SystemExit("pr.diff missing")

          # Parse unified diff and extract added lines with their new-file line numbers.
          added_by_file = {}
          current_file = None
          in_hunk = False
          new_line = 0

          diff_git_re = re.compile(r"^diff --git a/(.+?) b/(.+?)\\s*$")
          hunk_re = re.compile(r"^@@ -\\d+(?:,\\d+)? \\+(\\d+)(?:,\\d+)? @@")

          for raw in diff_path.read_text(encoding="utf-8", errors="replace").splitlines():
              m = diff_git_re.match(raw)
              if m:
                  current_file = m.group(2)
                  added_by_file.setdefault(current_file, [])
                  in_hunk = False
                  new_line = 0
                  continue

              if current_file is None:
                  continue

              if raw.startswith("Binary files ") or raw.startswith("GIT binary patch"):
                  in_hunk = False
                  continue

              hm = hunk_re.match(raw)
              if hm:
                  in_hunk = True
                  new_line = int(hm.group(1)) - 1
                  continue

              if not in_hunk:
                  continue

              if raw.startswith("\\ No newline at end of file"):
                  continue
              if raw.startswith("+++ ") or raw.startswith("--- "):
                  continue

              if raw.startswith("+") and not raw.startswith("+++"):
                  added_by_file[current_file].append(
                      {
                          "line_number": new_line + 1,
                          "content": raw[1:] if raw[1:] != "" else "\\n",
                      }
                  )
                  new_line += 1
              elif raw.startswith("-") and not raw.startswith("---"):
                  # deletion: only old line advances
                  continue
              else:
                  # context line: both sides advance
                  new_line += 1

          # Convert to added_lines schema (used in n8n payload)
          added_files = []
          file_index = 0
          for file_path, lines in added_by_file.items():
              if not lines:
                  continue
              added_lines = []
              for i, line in enumerate(lines):
                  added_lines.append(
                      {
                          "added_line_id": f"{file_index}-a{i}",
                          "line_number": line["line_number"],
                          "content": line["content"],
                      }
                  )
              added_files.append(
                  {
                      "fileIndex": file_index,
                      "file_path": file_path,
                      "status": "modified",
                      "added_lines": added_lines,
                  }
              )
              file_index += 1

          import json
          Path("added_lines.json").write_text(json.dumps(added_files, indent=2), encoding="utf-8")
          PY

      # Step 9: Inspect payload sizes for debugging
      - name: Debug payload size
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' }}
        run: |
          echo PR metadata size: $(stat -c%s pr.json) bytes
          echo Files metadata size: $(stat -c%s files.json) bytes
          echo Commits metadata size: $(stat -c%s commits.json) bytes
          echo Compressed diff size: $(stat -c%s pr.diff.gz) bytes
      # Step 9b: Evaluate diff char threshold
      - name: Evaluate diff char threshold
        id: diff_threshold
        shell: bash
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' }}
        run: |
          set -euo pipefail

          THRESHOLD=${MIN_DIFF_CHAR_THRESHOLD}
          if [[ ! $THRESHOLD =~ ^[0-9]+$ ]]; then
            echo "Invalid MIN_DIFF_CHAR_THRESHOLD='$THRESHOLD'; defaulting to 0"
            THRESHOLD=0
          fi

          CHAR_COUNT=$(wc -c < pr.diff | tr -d '[:space:]')
          {
            echo "diff_char_count=${CHAR_COUNT}"
            echo "threshold=${THRESHOLD}"
          } >> "$GITHUB_OUTPUT"

          if (( CHAR_COUNT < THRESHOLD )); then
            echo "skip_send=true" >> "$GITHUB_OUTPUT"
            echo "Filtered diff char count ${CHAR_COUNT} is below threshold ${THRESHOLD}; skipping downstream send."
          else
            echo "skip_send=false" >> "$GITHUB_OUTPUT"
            echo "Filtered diff char count ${CHAR_COUNT} meets threshold ${THRESHOLD}; continuing."
          fi


      # Step 9c: Short-circuit when below threshold
      - name: Diff below threshold
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' && steps.filter_files.outputs.addition_count != '0' && steps.diff_threshold.outputs.skip_send == 'true' }}
        run: |
          echo ℹ️ Diff char count (${{ steps.diff_threshold.outputs.diff_char_count }}) is below threshold (${{ steps.diff_threshold.outputs.threshold }}). Skipping n8n send.

      - name: Generate Run UUID
        id: run_uuid
        shell: bash
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' && steps.filter_files.outputs.addition_count != '0' && steps.diff_threshold.outputs.skip_send != 'true' }}
        run: echo "run_token=$(uuidgen)" >> "$GITHUB_OUTPUT"

      - name: Mask run token
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' && steps.run_uuid.outputs.run_token != '' }}
        env:
          RUN_TOKEN: ${{ steps.run_uuid.outputs.run_token }}
        run: echo "::add-mask::$RUN_TOKEN"
        
      - name: Combine and send to n8n webhook 
        id: send_payload
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' && steps.filter_files.outputs.addition_count != '0' && steps.diff_threshold.outputs.skip_send != 'true' }}
        env:
          N8N_WEBHOOK_URL: ${{ secrets.N8N_WEBHOOK_URL }}
          # Reused as HMAC secret ONLY (not sent in any header directly)
          N8N_SENDING_TOKEN: ${{ secrets.N8N_SENDING_TOKEN }}
          RUN_TOKEN: ${{ steps.run_uuid.outputs.run_token }}   # UUID, not GITHUB_TOKEN
          N8N_RECEIVING_TOKEN: ${{ secrets.N8N_RECEIVING_TOKEN }}
          N8N_ALLOWED_HOST: ${{ secrets.N8N_ALLOWED_HOST }}
        shell: bash
        run: |
          set -euo pipefail

          {
            echo "cancelled=false"
            echo "executed=true"
            echo "error=false"
          } >> "$GITHUB_OUTPUT"

          # 1) Validate URL & host
          HOST="$(python3 -c 'from urllib.parse import urlparse; import sys; u=urlparse(sys.argv[1]); print(u.hostname or "")' "$N8N_WEBHOOK_URL")"
          SCHEME="$(python3 -c 'from urllib.parse import urlparse; import sys; u=urlparse(sys.argv[1]); print(u.scheme or "")' "$N8N_WEBHOOK_URL")"
          if [[ -z "$HOST" || "$SCHEME" != "https" ]]; then
            echo "Invalid or non-https N8N_WEBHOOK_URL."
            echo "error=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          ALLOWED_HOST="$(printf '%s' "${N8N_ALLOWED_HOST:-}" | tr -d '\r\n ' )"
          if [[ -z "$ALLOWED_HOST" ]]; then
            echo "N8N_ALLOWED_HOST must be set."
            echo "error=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [[ "$HOST" != "$ALLOWED_HOST" ]]; then
            echo "Webhook host '$HOST' not allowed (expected '$ALLOWED_HOST')."
            echo "error=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # 2) Inputs check
          for f in pr.json files.json commits.json diff.b64 added_lines.json; do
            [[ -f "$f" ]] || { echo "$f missing"; echo "error=true" >> "$GITHUB_OUTPUT"; exit 0; }
          done

          # 3) Build payload.json (no secrets)
          DIFF_BASE64="$(tr -d '\n' < diff.b64)"
          if [[ -z "$DIFF_BASE64" ]]; then
            echo "diff.b64 is empty"
            echo "error=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          COMMIT_SHA_VALUE="$(printf '%s' "${COMMIT_SHA:-}" | tr -d '\r\n')"
          jq -n \
            --slurpfile pr pr.json \
            --slurpfile files files.json \
            --slurpfile commits commits.json \
            --slurpfile added added_lines.json \
            --arg diff_base64 "$DIFF_BASE64" \
            --arg commit_sha "$COMMIT_SHA_VALUE" \
            '{pr: $pr[0], files: $files[0], commits: $commits[0], added_lines: $added[0], diff_base64: $diff_base64, commit_sha: $commit_sha}' \
            > payload.json

          # 4) Size guard
          PAYLOAD_SIZE=$(stat -c%s payload.json)
          MAX_BYTES=$((10*1024*1024))
          if (( PAYLOAD_SIZE > MAX_BYTES )); then
            echo "Payload too large (${PAYLOAD_SIZE} bytes)."
            echo "error=true" >> "$GITHUB_OUTPUT"
            if command -v shred >/dev/null 2>&1; then shred -u payload.json 2>/dev/null || true; else rm -f payload.json || true; fi
            exit 0
          fi

          # 5) Compute HMAC over payload.json using N8N_SENDING_TOKEN (base64)
          if ! command -v openssl >/dev/null 2>&1; then
            echo "openssl not available for HMAC signing."
            echo "error=true" >> "$GITHUB_OUTPUT"
            if command -v shred >/dev/null 2>&1; then shred -u payload.json 2>/dev/null || true; else rm -f payload.json || true; fi
            exit 0
          fi
          SIG="$(openssl dgst -sha256 -hmac "$N8N_SENDING_TOKEN" -binary < payload.json | base64 | tr -d '\n')"

          # 6) Send (NO Authorization header)
          HEADER_FILE=$(mktemp)
          trap 'rm -f "$HEADER_FILE"' EXIT

          RESPONSE="$(curl -sS --fail-with-body --proto '=https' --tlsv1.2 \
            --retry 2 --retry-all-errors \
            --no-progress-meter --http1.1 --noproxy '*' \
            -D "$HEADER_FILE" -w $'\n%{http_code}' -X POST \
            -H "Content-Type: application/json" \
            -H "X-Run-Token: $RUN_TOKEN" \
            -H "X-Signature: sha256=${SIG}" \
            --data-binary @payload.json \
            "$N8N_WEBHOOK_URL")" || {
              echo "Request failed."
              echo "error=true" >> "$GITHUB_OUTPUT"
              if command -v shred >/dev/null 2>&1; then shred -u payload.json 2>/dev/null || true; else rm -f payload.json || true; fi
              rm -f "$HEADER_FILE"
              exit 0
            }

          # Remove payload quickly
          if command -v shred >/dev/null 2>&1; then shred -u payload.json 2>/dev/null || true; else rm -f payload.json || true; fi

          HTTP_BODY="$(printf '%s\n' "$RESPONSE" | sed '$d')"
          HTTP_STATUS="$(printf '%s\n' "$RESPONSE" | tail -n1)"
          echo "http_status=${HTTP_STATUS}" >> "$GITHUB_OUTPUT"
          echo "n8n responded with status: $HTTP_STATUS"

          if [[ "$HTTP_STATUS" -lt 200 || "$HTTP_STATUS" -ge 300 ]]; then
            echo "n8n workflow failed (HTTP $HTTP_STATUS)"
            echo "error=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          CTYPE_RAW="$(grep -i '^content-type:' "$HEADER_FILE" | tail -1 | tr -d '\r')"
          CTYPE_LOWER="$(printf '%s' "${CTYPE_RAW}" | tr '[:upper:]' '[:lower:]')"
          if [[ "$CTYPE_LOWER" != *"application/json"* ]]; then
            echo "Unexpected content-type '${CTYPE_RAW:-unknown}'."
            echo "error=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          STATUS="$(jq -r '.status // empty' <<< "$HTTP_BODY")"
          MATCHED="$(jq -r '.token // empty'  <<< "$HTTP_BODY")"

          if [[ -n "${N8N_RECEIVING_TOKEN:-}" ]]; then
            HEADER_SIG="$(python3 - <<'PY' "$HEADER_FILE"
          import sys
          from pathlib import Path

          header_path = Path(sys.argv[1])
          sig = ""
          for line in header_path.read_text().splitlines():
              if line.lower().startswith("x-response-signature:"):
                  sig = line.split(":", 1)[1].strip()
                  break
          print(sig, end="")
          PY
          )"
            if [[ -n "$HEADER_SIG" ]]; then
              PAYLOAD_FOR_SIG="$(
                HTTP_BODY_VAR="$HTTP_BODY" python3 - <<'PY'
          import json
          import os

          body = os.environ.get("HTTP_BODY_VAR", "")
          try:
              data = json.loads(body)
          except json.JSONDecodeError:
              data = None

          payload = data.get("payload") if isinstance(data, dict) else None
          if (
              not isinstance(payload, list)
              or not payload
              or not isinstance(payload[0], dict)
              or not isinstance(payload[0].get("payload"), str)
          ):
              raise SystemExit(0)

          print(payload[0]["payload"], end="")
          PY
              )"
              if [[ -z "$PAYLOAD_FOR_SIG" ]]; then
                PAYLOAD_FOR_SIG="$HTTP_BODY"
              fi
              EXPECTED_SIG="sha256=$(printf '%s' "$PAYLOAD_FOR_SIG" | openssl dgst -binary -sha256 -hmac "$N8N_RECEIVING_TOKEN" | base64 | tr -d '\n')"
              if [[ "$HEADER_SIG" != "$EXPECTED_SIG" ]]; then
                BODY_SIG="sha256=$(printf '%s' "$HTTP_BODY" | openssl dgst -binary -sha256 -hmac "$N8N_RECEIVING_TOKEN" | base64 | tr -d '\n')"
                if [[ "$HEADER_SIG" != "$BODY_SIG" ]]; then
                  echo "Response signature mismatch."
                  echo "error=true" >> "$GITHUB_OUTPUT"
                  exit 0
                fi
              fi
            else
              echo "Missing X-Response-Signature header."
              echo "error=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          if [[ "$STATUS" == "cancelled" ]]; then
            echo "n8n workflow reported cancellation; skipping downstream processing."
            echo "cancelled=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # RUN_TOKEN only in header; n8n should echo it back in .token
          if [[ -z "$MATCHED" || "$MATCHED" != "$RUN_TOKEN" || "$STATUS" != "completed" ]]; then
            echo "n8n workflow failed or token mismatch (status='$STATUS')."
            echo "error=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          SANITIZED_BODY="$HTTP_BODY"
          if command -v jq >/dev/null 2>&1; then
            if SANITIZED=$(printf '%s' "$HTTP_BODY" | jq -c '
              def scrub:
                if type == "object" then
                  with_entries(
                    (.key | ascii_downcase) as $k
                    | if ($k == "receiving_token" or $k == "token" or $k == "auth" or $k == "authorization" or $k == "secrets" or $k == "cookies" or $k == "headers")
                      then empty
                      else (.value |= scrub)
                      end
                  )
                elif type == "array" then
                  map(scrub)
                else
                  .
                end;
              scrub
            ' 2>/dev/null); then
              if [[ -n "$SANITIZED" ]]; then
                SANITIZED_BODY="$SANITIZED"
              fi
            fi
          fi

          BODY_B64=$(printf '%s' "$SANITIZED_BODY" | base64 -w 0)
          echo "response_payload=${BODY_B64}" >> "$GITHUB_OUTPUT"

          echo "ok=true" >> "$GITHUB_OUTPUT"


      - name: Enforce n8n send failure
        if: ${{ steps.send_payload.outputs.error == 'true' }}
        run: |
          echo n8n send step reported failure. Marking job as failed.
          exit 1

      # Step 11: Short-circuit when nothing qualifies
      - name: No eligible files to send
        if: ${{ steps.trigger_phrase.outputs.triggered == 'true' && steps.oneshot.outputs.proceed == 'true' && steps.sha_guard.outputs.sha_ok == 'true' && steps.checkout.outcome == 'success' && steps.filter_files.outputs.addition_count == '0' }}
        run: echo ℹ️ No eligible additions after filtering llms/.ai paths. Skipping n8n send.

      - name: Securely delete diff artifacts
        if: ${{ always() }}
        run: |
          set -euo pipefail
          for target in pr.diff pr.diff.gz diff.b64; do
            if [[ -f "$target" ]]; then
              if command -v shred >/dev/null 2>&1; then
                shred -u "$target" || rm -f "$target"
              else
                rm -f "$target"
              fi
            fi
          done

      - name: Complete one-shot check-run
        if: ${{ always() && steps.oneshot.outputs.check_run_id != '' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          CHECK_RUN_ID: ${{ steps.oneshot.outputs.check_run_id }}
          PR_NUMBER: ${{ env.PR_NUMBER }}
          COMMIT_SHA: ${{ env.COMMIT_SHA }}
          RUN_URL: ${{ steps.run_context.outputs.run_url }}
          PROCEED: ${{ steps.oneshot.outputs.proceed }}
          SKIP_REASON: ${{ steps.oneshot.outputs.skip_reason }}
          SHA_OK: ${{ steps.sha_guard.outputs.sha_ok }}
          CHECKOUT_OK: ${{ steps.checkout.outcome == 'success' && 'true' || 'false' }}
          ADDITION_COUNT: ${{ steps.filter_files.outputs.addition_count || '0' }}
          DIFF_SKIP: ${{ steps.diff_threshold.outputs.skip_send || 'false' }}
          SEND_EXECUTED: ${{ steps.send_payload.outputs.executed || 'false' }}
          SEND_ERROR: ${{ steps.send_payload.outputs.error || 'false' }}
          SEND_CANCELLED: ${{ steps.send_payload.outputs.cancelled || 'false' }}
        shell: bash
        run: |
          set -euo pipefail

          conclusion="neutral"
          title="n8n trigger"
          reason=""

          if [[ "${PROCEED}" != "true" ]]; then
            reason="${SKIP_REASON:-not_proceeding}"
          elif [[ "${SHA_OK}" != "true" ]]; then
            reason="head_sha_changed_or_missing"
          elif [[ "${CHECKOUT_OK}" != "true" ]]; then
            reason="checkout_failed"
          elif [[ "${ADDITION_COUNT}" == "0" ]]; then
            reason="no_eligible_additions"
          elif [[ "${DIFF_SKIP}" == "true" ]]; then
            reason="diff_below_threshold"
          elif [[ "${SEND_CANCELLED}" == "true" ]]; then
            reason="cancelled"
          elif [[ "${SEND_ERROR}" == "true" ]]; then
            conclusion="failure"
            reason="send_error"
          elif [[ "${SEND_EXECUTED}" == "true" ]]; then
            conclusion="success"
            reason="sent"
          else
            reason="skipped"
          fi

          completed_at="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          summary="$(printf 'PR: #%s\nCommit: %s\nRun: %s\nResult: %s\n' "${PR_NUMBER:-unknown}" "${COMMIT_SHA:-unknown}" "${RUN_URL:-unknown}" "${reason}")"

          gh api -X PATCH -H "Accept: application/vnd.github+json" "repos/${REPO}/check-runs/${CHECK_RUN_ID}" \
            -f status="completed" \
            -f completed_at="${completed_at}" \
            -f conclusion="${conclusion}" \
            -f output[title]="${title}" \
            -f output[summary]="${summary}" >/dev/null

  receive-validate-and-comment:
    runs-on: ubuntu-latest
    needs:
      - gather-and-send
    if: ${{ needs.gather-and-send.result == 'success' && needs.gather-and-send.outputs.triggered == 'true' && needs.gather-and-send.outputs.filtered_addition_count != '0' && needs.gather-and-send.outputs.should_send == 'true' }}
    environment: n8n-receiving
    permissions:
      contents: read
      pull-requests: write
    steps:
      # Step 13: Re-checkout repo (fresh workspace)
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          ref: ${{ needs.gather-and-send.outputs.commit_sha }}

      # Step 14: Restore response payload from upstream output
      - name: Restore response payload
        id: restore_payload
        if: ${{ needs.gather-and-send.outputs.response_payload != '' }}
        run: |
          set -euo pipefail
          payload='${{ needs.gather-and-send.outputs.response_payload }}'
          if [ -z "$payload" ]; then
            echo "Response payload missing; exiting."
            exit 1
          fi
          printf '%s' "$payload" | base64 -d > response_body.json
          echo "restored=true" >> "$GITHUB_OUTPUT"

      # Step 16: Prepare grouped review batches
      - name: Prepare batched review payloads
        if: ${{ steps.restore_payload.outputs.restored == 'true' }}
        run: |
          python3 - <<'PY'
          from pathlib import Path
          import json

          raw = Path('response_body.json').read_text() or 'null'
          data = json.loads(raw)
          if isinstance(data, list):
              data = data[0] if data else {}

          payload_entries = data.get('payload') or []
          if isinstance(payload_entries, str):
              try:
                  payload_entries = json.loads(payload_entries)
              except json.JSONDecodeError:
                  payload_entries = []
          if isinstance(payload_entries, dict):
              primary_payload = payload_entries
          elif isinstance(payload_entries, list) and payload_entries:
              primary_payload = payload_entries[0]
          else:
              primary_payload = {}

          payloads = (
              data.get('prepared_comment_payloads')
              or primary_payload.get('prepared_comment_payloads')
              or []
          )

          def normalize(raw):
              path = raw.get('path') or raw.get('file_path')
              if not path:
                  return None
              body = (raw.get('body') or '').strip()
              if not body:
                  body = '```suggestion\n```\n'
              comment = {'path': path, 'body': body}

              if 'line' in raw and raw['line'] is not None:
                  comment['line'] = raw['line']
                  if raw.get('side'):
                      comment['side'] = raw['side']
                  if raw.get('start_line') is not None:
                      comment['start_line'] = raw['start_line']
                      comment['start_side'] = raw.get('start_side', 'RIGHT')
              elif 'position' in raw and raw['position'] is not None:
                  comment['position'] = raw['position']

              commit_id = raw.get('commit_id')
              return comment, commit_id

          normalized = [normalize(raw) for raw in payloads]
          normalized = [item for item in normalized if item is not None]
          seen = set()
          deduped = []
          for comment, cid in normalized:
              key = (cid or '', json.dumps(comment, sort_keys=True))
              if key in seen:
                  continue
              seen.add(key)
              deduped.append((comment, cid))

          comments = [item[0] for item in deduped]
          commit_ids = [item[1] for item in deduped]

          chunk_size = 30
          total = len(comments)
          batches = []
          for start in range(0, total, chunk_size):
              chunk = comments[start:start + chunk_size]
              summary = f"Automated style guide suggestions ({start + 1}-{start + len(chunk)} of {total})"
              chunk_commit_ids = {cid for cid in commit_ids[start:start + chunk_size] if cid}
              batch = {'body': summary, 'comments': chunk}
              if len(chunk_commit_ids) == 1:
                  batch['commit_id'] = chunk_commit_ids.pop()
              batches.append(batch)

          status = data.get('status') or primary_payload.get('status')
          owner = data.get('repo_owner') or primary_payload.get('repo_owner')
          repo = data.get('repo_name') or primary_payload.get('repo_name')
          pr_number = data.get('pr_number') or primary_payload.get('pr_number')

          output = {
              'status': status,
              'owner': owner,
              'repo': repo,
              'pr': pr_number,
              'batches': batches
          }
          Path('review_batches.json').write_text(json.dumps(output, indent=2))
          PY

      # Step 17: Post grouped inline suggestions
      - name: Post batched inline suggestions
        if: ${{ steps.restore_payload.outputs.restored == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          STATUS=$(jq -r '.status // empty' review_batches.json)
          if [ "$STATUS" != "completed" ]; then
            echo "n8n output not completed (status='$STATUS')"
            exit 1
          fi

          OWNER=$(jq -r '.owner // empty' review_batches.json)
          REPO=$(jq -r '.repo // empty' review_batches.json)
          PR=$(jq -r '.pr // empty' review_batches.json)
          if [ -z "$OWNER" ] || [ -z "$REPO" ] || [ -z "$PR" ]; then
            echo "Missing repo context."
            exit 1
          fi

          BATCH_COUNT=$(jq '.batches | length' review_batches.json)
          if [ "$BATCH_COUNT" -eq 0 ]; then
            echo "No suggestions returned; nothing to post."
            exit 0
          fi

          echo "Posting $BATCH_COUNT suggestion batch(es) to $OWNER/$REPO#$PR"

          for index in $(jq -r '.batches | keys[]' review_batches.json); do
            BODY_SUMMARY=$(jq -r ".batches[$index].body" review_batches.json)
            COMMENTS=$(jq ".batches[$index].comments" review_batches.json)
            COMMIT_ID=$(jq -r ".batches[$index].commit_id // empty" review_batches.json)

            if [ -n "$COMMIT_ID" ] && [ "$COMMIT_ID" != "null" ]; then
              PAYLOAD=$(jq -n --arg body "$BODY_SUMMARY" --argjson comments "$COMMENTS" --arg commit "$COMMIT_ID" '{event:"COMMENT", body:$body, comments:$comments, commit_id:$commit}')
            else
              PAYLOAD=$(jq -n --arg body "$BODY_SUMMARY" --argjson comments "$COMMENTS" '{event:"COMMENT", body:$body, comments:$comments}')
            fi

            RESP=$(curl -sS --fail-with-body --proto '=https' --tlsv1.2 \
              --retry 2 --retry-all-errors \
              --no-progress-meter --http1.1 --noproxy '*' \
              -w '%{http_code}' -X POST \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${OWNER}/${REPO}/pulls/${PR}/reviews" \
              -d "$PAYLOAD") || {
                echo "curl failed while posting review batch"
                exit 1
              }

            CODE=${RESP:(-3)}
            BODY=${RESP%$CODE}

            if [[ "$CODE" -lt 200 || "$CODE" -ge 300 ]]; then
              echo "❌ Failed to post review batch (HTTP $CODE)"
              echo "$BODY"
              exit 1
            fi

            URL=$(echo "$BODY" | jq -r '.html_url // empty')
            if [ -n "$URL" ]; then
              echo "✅ Posted review batch ${index} → $URL"
            else
              echo "✅ Posted review batch ${index}"
            fi
          done

          echo "-- Skipped upstream comments --"
          jq -r 'if type=="array" then .[0] else . end | .skipped_comments // [] | .[] | \(.file_path // -)#L\(.line_number // -): \(.reason // -)' response_body.json || echo "None."

          echo "✅ Done. Suggestions posted."

      # Step 18: Publish any verification reviews
      - name: Post verification comments
        if: ${{ steps.restore_payload.outputs.restored == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          RESPONSE_BODY=$(cat response_body.json)

          VERIFS=$(
            printf '%s' "$RESPONSE_BODY" | jq -c '
              (if type=="array" then .[0] else . end) as $o
              | def to_arr(x):
                  if (x|type) == "array" then x
                  elif (x|type) == "object" then [x]
                  elif (x|type) == "string" then (try (x|fromjson) catch [])
                  else [] end;

              [
                (to_arr($o.reviews) // []) as $r1
                  | ($r1 | map(select(((.type? | tostring | ascii_downcase) == "verification")))
                            | map(.formattedReview // .review // .body // .comment // .text // .content // "")),
                (to_arr($o.review) // []) as $r2
                  | ($r2 | map(select(((.type? | tostring | ascii_downcase) == "verification")))
                            | map(.formattedReview // .review // .body // .comment // .text // .content // "")),

                ($o | .. | objects
                  | select(((.type? | tostring | ascii_downcase) == "verification"))
                  | (.formattedReview // .review // .body // .comment // .text // .content // ""))

              ]
              | flatten
              | map(select(type == "string" and (length > 0)))
              | unique
            '
          )

          COUNT=$(printf '%s' "$VERIFS" | jq 'length')
          if [ "$COUNT" -eq 0 ]; then
            echo "No verification reviews found; skipping."
            exit 0
          fi

          OWNER=$(printf '%s' "$RESPONSE_BODY" | jq -r 'if type=="array" then .[0].repo_owner else .repo_owner end // empty')
          REPO=$(printf '%s' "$RESPONSE_BODY" | jq -r 'if type=="array" then .[0].repo_name else .repo_name end // empty')
          PR=$(printf '%s' "$RESPONSE_BODY" | jq -r 'if type=="array" then .[0].pr_number else .pr_number end // empty')

          if [ -z "$OWNER" ] || [ -z "$REPO" ] || [ -z "$PR" ]; then
            echo "Missing repo context; skipping verification comments."
            exit 0
          fi

          echo "Found $COUNT verification review(s). Preview:"
          printf '%s' "$VERIFS" | jq -r 'to_entries[] | "\(.key):  " + (.value | .[0:160] + (if length>160 then "..." else "" end))'

          printf '%s' "$VERIFS" | jq -r '.[] + "\u0000"' | while IFS= read -r -d '' BODY; do
            if [ -z "${BODY//[$'\t\r\n ']}" ]; then
              echo "Skipping empty verification body"
              continue
            fi

            JSON_PAYLOAD=$(jq -nc --arg b "$BODY" '{body:$b}')
            RESP=$(curl -sS --fail-with-body --proto '=https' --tlsv1.2 \
              --retry 2 --retry-all-errors \
              --no-progress-meter --http1.1 --noproxy '*' \
              -w '%{http_code}' -X POST \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${OWNER}/${REPO}/issues/${PR}/comments" \
              -d "$JSON_PAYLOAD") || {
                echo "curl failed while posting verification comment"
                exit 1
              }

            CODE=${RESP:(-3)}
            RBODY=${RESP%$CODE}

            if [[ "$CODE" -lt 200 || "$CODE" -ge 300 ]]; then
              echo "❌ Failed to post verification comment (HTTP $CODE)"
              echo "$RBODY"
              exit 1
            fi

            url=$(printf '%s' "$RBODY" | jq -r '.html_url // empty')
            if [ -n "$url" ]; then
              echo "✅ Posted verification review → $url"
            else
              echo "✅ Posted verification review"
            fi
          done

          echo ✅ Done posting verification reviews.

      # Step 18b: Clean up response artifacts
      - name: Remove response payload
        if: ${{ always() }}
        run: |
          rm -f response_body.json review_batches.json || true

  notify-on-failure:
    runs-on: ubuntu-latest
    needs:
      - gather-and-send
      - receive-validate-and-comment
    permissions:
      contents: read
      pull-requests: read
    if: ${{ always() && ((needs.gather-and-send.result == 'failure' && (needs.gather-and-send.outputs.send_executed != 'true' || needs.gather-and-send.outputs.send_error == 'true')) || needs.receive-validate-and-comment.result == 'failure') }}
    env:
      GATHER_RESULT: ${{ needs.gather-and-send.result }}
      RECEIVE_RESULT: ${{ needs.receive-validate-and-comment.result }}
      PR_NUMBER: ${{ needs.gather-and-send.outputs.pr_number }}
      REPOSITORY: ${{ needs.gather-and-send.outputs.repository || github.repository }}
      RUN_URL: ${{ needs.gather-and-send.outputs.run_url || format('{0}/{1}/actions/runs/{2}', github.server_url, github.repository, github.run_id) }}
      WORKFLOW_NAME: ${{ github.workflow }}
      RUN_ID: ${{ github.run_id }}
      RUN_ATTEMPT: ${{ github.run_attempt }}
      ERROR_WEBHOOK_URL: ${{ secrets.ERROR_WEBHOOK_URL }}
      ACTOR: ${{ github.actor }}
      SEND_EXECUTED: ${{ needs.gather-and-send.outputs.send_executed }}
      SEND_ERROR: ${{ needs.gather-and-send.outputs.send_error }}
    steps:
      - name: Evaluate failure state
        id: alert
        run: |
          set -euo pipefail
          gather="${GATHER_RESULT:-unknown}"
          receive="${RECEIVE_RESULT:-skipped}"
          if [[ "$gather" == "failure" || "$receive" == "failure" ]]; then
            echo "alert=true" >> "$GITHUB_OUTPUT"
            echo "Failure detected (gather=$gather, receive=$receive)."
          else
            echo "alert=false" >> "$GITHUB_OUTPUT"
            echo "No downstream alert required (gather=$gather, receive=$receive)."
          fi

      - name: Send failure webhook
        if: ${{ steps.alert.outputs.alert == 'true' }}
        run: |
          set -euo pipefail

          if [[ -z ${ERROR_WEBHOOK_URL:-} ]]; then
            echo "Webhook URL secret not configured; skipping alert dispatch."
            exit 0
          fi

          gather="${GATHER_RESULT:-unknown}"
          receive="${RECEIVE_RESULT:-skipped}"
          pr="${PR_NUMBER:-unknown}"
          repo="${REPOSITORY:-${{ github.repository }}}"

          payload=$(jq -n \
            --arg repo "$repo" \
            --arg pr "$pr" \
            --arg gather_status "$gather" \
            --arg receive_status "$receive" \
            --arg run_url "$RUN_URL" \
            --arg workflow "$WORKFLOW_NAME" \
            --arg run_id "$RUN_ID" \
            --arg run_attempt "$RUN_ATTEMPT" \
            --arg actor "$ACTOR" \
            '{repository:$repo, pr_number:$pr, gather_status:$gather_status, receive_status:$receive_status, run_url:$run_url, workflow:$workflow, run_id:$run_id, run_attempt:$run_attempt, actor:$actor}')

          curl -sS --fail-with-body --proto '=https' --tlsv1.2 \
            --retry 2 --retry-all-errors \
            --no-progress-meter --http1.1 --noproxy '*' \
            -X POST \
            -H "Content-Type: application/json" \
            --data "$payload" \
            "$ERROR_WEBHOOK_URL"
